////////////////////////////////////////////////////////////////////////
// Class:       Supera
// Module Type: analyzer
// File:        Supera_module.cc
//
// Generated at Thu Apr  7 07:34:02 2016 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// nutools
#include "SimulationBase/MCTruth.h"
// larsoft
#include "larcore/Geometry/Geometry.h"
#include "lardata/RecoBase/Wire.h"
#include "lardata/MCBase/MCTrack.h"
#include "lardata/MCBase/MCShower.h"
// larcv
#include "MCParticleTree.h"
#include "DataFormat/IOManager.h"
#include "DataFormat/EventImage2D.h"
#include "DataFormat/EventROI.h"
#include "Base/larbys.h"
#include "SuperaUtils.h"
#include "DataFormat/ProductMap.h"

class Supera;

class Supera : public art::EDAnalyzer {
public:
  explicit Supera(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Supera(Supera const &) = delete;
  Supera(Supera &&) = delete;
  Supera & operator = (Supera const &) = delete;
  Supera & operator = (Supera &&) = delete;

  void beginJob();
  void endJob();

  // Required functions.
  void analyze(art::Event const & e) override;

  const ::larcv::logger& logger() const { return _logger;}
  
private:

  ::larcv::supera::MCParticleTree<simb::MCTruth,sim::MCTrack,sim::MCShower> _mctp;
  ::larcv::logger _logger;
  ::larcv::IOManager _larcv_io;
  std::string _producer_simch;
  std::string _producer_wire;
  std::string _producer_gen;
  std::string _producer_mcreco;
  std::vector<size_t> _event_image_cols;
  std::vector<size_t> _event_image_rows;
  std::vector<size_t> _event_comp_rows;
  std::vector<size_t> _event_comp_cols;
  double _min_time;
  double _min_wire;
  ::larcv::Image2D _full_image;

};

Supera::Supera(fhicl::ParameterSet const & main_cfg)
  : EDAnalyzer(main_cfg)
  , _larcv_io(::larcv::IOManager::kWRITE)
{
  auto const* geom = ::lar::providerFrom<geo::Geometry>();

  _larcv_io.set_out_file(main_cfg.get<std::string>("OutFileName"));

  _producer_simch  = main_cfg.get<std::string>("SimChProducer");
  _producer_wire   = main_cfg.get<std::string>("WireProducer");
  _producer_gen    = main_cfg.get<std::string>("GenProducer");
  _producer_mcreco = main_cfg.get<std::string>("MCRecoProducer");

  _min_time = main_cfg.get<double>("MinTime");
  _min_wire = main_cfg.get<double>("MinWire");

  _event_image_rows = main_cfg.get<std::vector<size_t> >("EventImageRows");
  _event_image_cols = main_cfg.get<std::vector<size_t> >("EventImageCols");
  _event_comp_rows  = main_cfg.get<std::vector<size_t> >("EventCompRows");
  _event_comp_cols  = main_cfg.get<std::vector<size_t> >("EventCompCols");

  // Check/Enforce conditions
  _logger.set((::larcv::msg::Level_t)(main_cfg.get<unsigned short>("Verbosity")));
  _mctp.configure(main_cfg.get<larcv::supera::Config_t>("MCParticleTree"));

  if(geom->Nplanes() != _event_image_rows.size()) throw larcv::larbys("EventImageRows size != # planes!");
  if(geom->Nplanes() != _event_image_cols.size()) throw larcv::larbys("EventImageCols size != # planes!");
  if(geom->Nplanes() != _event_comp_rows.size())  throw larcv::larbys("EventCompRows size != # planes!");
  if(geom->Nplanes() != _event_comp_cols.size())  throw larcv::larbys("EventCompCols size != # planes!");

  for(auto const& v : _event_image_rows){ if(!v) throw larcv::larbys("Event-Image row size is 0!"); }
  for(auto const& v : _event_image_cols){ if(!v) throw larcv::larbys("Event-Image col size is 0!"); }
  for(auto const& v : _event_comp_rows){ if(!v) throw larcv::larbys("Event-Image row comp factor is 0!"); }
  for(auto const& v : _event_comp_cols){ if(!v) throw larcv::larbys("Event-Image col comp factor is 0!"); }

}

void Supera::beginJob()
{
  _larcv_io.initialize();
}

void Supera::endJob()
{
  _larcv_io.finalize();
}

void Supera::analyze(art::Event const & e)
{
  //auto wire_h = storage->get_data<event_wire>(_producer_wire);
  art::Handle<std::vector<recob::Wire> > wire_h; e.getByLabel(_producer_wire,wire_h);
  
  //if(!wire_h) { throw DataFormatException("Could not load wire data!"); }
  if(!wire_h.isValid()) { throw larcv::larbys("Could not load wire data!"); }

  auto const* geom = ::lar::providerFrom<geo::Geometry>();
  //auto geom = ::larutil::Geometry::GetME();

  auto event_image_v = (::larcv::EventImage2D*)(_larcv_io.get_data(::larcv::kProductImage2D,"event_image"));

  //
  // 0) Construct Event-image ROI
  //
  std::map<larcv::PlaneID_t,larcv::ImageMeta> image_meta_m;
  for(size_t p=0; p<geom->Nplanes(); ++p) {

    size_t cols = _event_image_cols[p] * _event_comp_cols[p];
    size_t rows = _event_image_rows[p] * _event_comp_rows[p];

    auto meta = ::larcv::ImageMeta(cols-1,rows-1,
				   rows,cols,
				   _min_wire,_min_time+rows-1,
				   p);
    image_meta_m.insert(std::make_pair(p,meta));
  }

  //
  // 1) Construct Interaction/Particle ROIs
  //
  art::Handle<std::vector<simb::MCTruth> > mctruth_h;  e.getByLabel( _producer_gen,    mctruth_h  );
  art::Handle<std::vector<sim::MCTrack > > mctrack_h;  e.getByLabel( _producer_mcreco, mctrack_h  );
  art::Handle<std::vector<sim::MCShower> > mcshower_h; e.getByLabel( _producer_mcreco, mcshower_h );
  //auto mctruth_h  = storage->get_data<event_mctruth>(_producer_gen);
  //auto mctrack_h  = storage->get_data<event_mctrack>(_producer_mcreco);
  //auto mcshower_h = storage->get_data<event_mcshower>(_producer_mcreco);
  _mctp.clear();
  _mctp.DefinePrimary(*mctruth_h);
  _mctp.RegisterSecondary(*(mctrack_h));
  if(_producer_simch.empty()) 
    _mctp.RegisterSecondary(*(mcshower_h));
  else{
    art::Handle<std::vector<sim::SimChannel> > simch_h; e.getByLabel( _producer_simch, simch_h );
    //auto simch_h = storage->get_data<event_simch>(_producer_simch);
    _mctp.RegisterSecondary(*(mcshower_h),*(simch_h));
  }
  _mctp.UpdatePrimaryROI();
  auto int_roi_v = _mctp.GetPrimaryROI();

  auto roi_v = (::larcv::EventROI*)(_larcv_io.get_data(::larcv::kProductROI,"event_roi"));

  for(auto& int_roi : int_roi_v) {

    //
    // Primary: store overlapped ROI
    //
    std::vector<larcv::ImageMeta> pri_bb_v;

    for(auto const& bb : int_roi.first.BB()) {
      auto iter = image_meta_m.find(bb.plane());
      if(iter == image_meta_m.end()) continue;
      try{
	pri_bb_v.push_back(bb.overlap((*iter).second));
      }catch(const ::larcv::larbys& err){
	break;
      }
    }

    if(pri_bb_v.size() != int_roi.first.BB().size()) {
      LARCV_NORMAL() << "Requested to register Interaction..." << std::endl
                     << int_roi.first.dump() << std::endl;
      LARCV_NORMAL() << "No overlap found in image region and Interaction ROI. Skipping..." << std::endl;
      continue;
    }
    int_roi.first.SetBB(pri_bb_v);
    LARCV_INFO() << "Registering Interaction..." << std::endl
		 << int_roi.first.dump() << std::endl;
    roi_v->Append(int_roi.first);

    //
    // Secondaries
    // 
    for(auto& roi : int_roi.second) {

      std::vector<larcv::ImageMeta> sec_bb_v;

      for(auto const& bb : roi.BB()) {
	auto iter = image_meta_m.find(bb.plane());
	if(iter == image_meta_m.end()) continue;
	try{
	  sec_bb_v.push_back(bb.overlap((*iter).second));
	}catch(const ::larcv::larbys& err) {
	  break;
	}
      }
      if(sec_bb_v.size() != roi.BB().size()) {
	LARCV_INFO() << "Requested to register Secondary..." << std::endl
		     << roi.dump() << std::endl;
	LARCV_INFO() << "No overlap found in image region and Particle ROI. Skipping..." << std::endl;
	continue;
      }
      roi.SetBB(sec_bb_v);
      LARCV_INFO() << "Registering Secondary..." << std::endl
		   << roi.dump() << std::endl;
      roi_v->Append(roi);
    }
  }

  //
  // If no ROI, skip this event
  //
  if(roi_v->ROIArray().empty()) {
    _larcv_io.save_entry();
    //return true;
    return;
  }
  //
  // If no Interaction ImageMeta (Interaction ROI object w/ no real ROI), skip this event
  //
  bool skip = true;
  for(auto const& roi : roi_v->ROIArray()) {
    if(roi.MCSTIndex() != ::larcv::kINVALID_INDEX) continue;
    if(roi.BB().size() == geom->Nplanes()) {
      skip=false;
      break;
    }
  }
  if(skip) {
    _larcv_io.save_entry();
    //return true;
    return;
  }

  //
  // Extract image if there's any ROI
  //
  for(size_t p=0; p<geom->Nplanes(); ++p) {

    auto const& full_meta = (*(image_meta_m.find(p))).second;

    // Create full resolution image
    _full_image.reset(full_meta);
    ::larcv::supera::Fill<recob::Wire>(_full_image,*wire_h);
    _full_image.index(event_image_v->Image2DArray().size());

    // Now extract each high-resolution interaction image
    for(auto const& roi : roi_v->ROIArray()) {
      // Only care about interaction
      if(roi.MCSTIndex() != ::larcv::kINVALID_INDEX) continue;
      auto const& roi_meta = roi.BB(p);
      ::larcv::ImageMeta bb(roi_meta.width(),roi_meta.height(),
			    roi_meta.rows(),roi_meta.height(),
			    roi_meta.min_x(), roi_meta.max_y(),
			    roi_meta.plane());
      // Retrieve cropped full resolution image
      auto int_img_v = (::larcv::EventImage2D*)(_larcv_io.get_data(::larcv::kProductImage2D,Form("mcint%02d",roi.MCTIndex())));
      auto hires_img = _full_image.crop(bb);
      int_img_v->Emplace(std::move(hires_img));
    }

    // Finally compress and store as event image
    auto comp_meta = ::larcv::ImageMeta(_full_image.meta());
    comp_meta.update(_event_image_rows[p],_event_image_cols[p]);
    ::larcv::Image2D img(std::move(comp_meta),
			 std::move(_full_image.copy_compress(_event_image_rows[p],_event_image_cols[p])));
    event_image_v->Emplace(std::move(img));
  }

  _larcv_io.save_entry();
  //return true;
  return;
}

DEFINE_ART_MODULE(Supera)
