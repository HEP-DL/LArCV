////////////////////////////////////////////////////////////////////////
// Class:       Supera
// Module Type: analyzer
// File:        Supera_module.cc
//
// Generated at Thu Apr  7 07:34:02 2016 by Kazuhiro Terao using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// nutools
#include "SimulationBase/MCTruth.h"
// larsoft
#include "larcore/Geometry/Geometry.h"
#include "larsim/Simulation/SimChannel.h"
#include "lardata/RecoBase/Wire.h"
#include "lardata/MCBase/MCTrack.h"
#include "lardata/MCBase/MCShower.h"
// larcv
#include "SuperaCore.h"

class Supera;

class Supera : public art::EDAnalyzer {
public:
  explicit Supera(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Supera(Supera const &) = delete;
  Supera(Supera &&) = delete;
  Supera & operator = (Supera const &) = delete;
  Supera & operator = (Supera &&) = delete;

  void beginJob();
  void endJob();

  // Required functions.
  void analyze(art::Event const & e) override;

  const ::larcv::logger& logger() const { return _logger;}
  
private:

  ::larcv::supera::SuperaCore<larlite::wire,
			      larlite::mctruth, larlite::mctrack, larlite::mcshower, larlite::simch> _core;

};

Supera::Supera(fhicl::ParameterSet const & main_cfg)
  : EDAnalyzer(main_cfg)
{
  _core.configure(main_cfg);
}

void Supera::beginJob()
{
  _core.initialize();
}

void Supera::endJob()
{
  _core.finalize();
}

void Supera::analyze(art::Event const & e)
{

  //_core.set_id();

  art::Handle<std::vector<recob::Wire> > wire_h;
  e.getByLabel(_core.producer_wire(),wire_h);

  if(!wire_h.isValid()) { throw DataFormatException("Could not load wire data!"); }

  bool status=true;
  if(_core.use_mc()) {

    art::Handle<std::vector<simb::MCTruth> > mctruth_h;
    art::Handle<std::vector<sim::MCTrack>  > mctrack_h;
    art::Handle<std::vector<sim::MCShower> > mcshower_h;
    e.getByLabel(_core.producer_generator(), mctruth_h);
    e.getByLabel(_core.producer_mcreco(),    mctrack_h);
    e.getByLabel(_core.producer_mcreco(),    mcshower_h);

    if(!mctruth_h.isValid() || !mctrack_h.isValid() || !mcshower_h.isValid())

      throw DataFormatException("Necessary MC info missing...");

    if(_core.producer_simch().empty()) {

      std::vector<larlite::simch> empty_simch;
      status = _core.process_event(*wire_h, *mctruth_h, *mctrack_h, *mcshower_h, empty_simch);

    }else{

      art::Handle<std::vector<sim::SimChannel> > simch_h;
      e.getByLabel(_core.producer_simch(), simch_h);
      if(!simch_h.isValid()) throw DataFormatException("SimChannel requested but not available");
      status = _core.process_event(*wire_h, *mctruth_h, *mctrack_h, *mcshower_h, *simch_h);
    }
  }else{
    std::vector<larlite::mctruth>  empty_mctruth;
    std::vector<larlite::mctrack>  empty_mctrack;
    std::vector<larlite::mcshower> empty_mcshower;
    std::vector<larlite::simch>    empty_simch;
    status = _core.process_event(*wire_h,empty_mctruth,empty_mctrack,empty_mcshower,empty_simch);
  }
  return status;
}

DEFINE_ART_MODULE(Supera)
